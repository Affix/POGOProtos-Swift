// Generated by the Protocol Buffers 3.0 compiler.  DO NOT EDIT!
// Source file "UseItemCaptureResponse.proto"
// Syntax "Proto3"

import Foundation
import ProtocolBuffers


public struct Pogoprotos { public struct Networking { public struct Responses { }}}

public func == (lhs: Pogoprotos.Networking.Responses.UseItemCaptureResponse, rhs: Pogoprotos.Networking.Responses.UseItemCaptureResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasSuccess == rhs.hasSuccess) && (!lhs.hasSuccess || lhs.success == rhs.success)
  fieldCheck = fieldCheck && (lhs.hasItemCaptureMult == rhs.hasItemCaptureMult) && (!lhs.hasItemCaptureMult || lhs.itemCaptureMult == rhs.itemCaptureMult)
  fieldCheck = fieldCheck && (lhs.hasItemFleeMult == rhs.hasItemFleeMult) && (!lhs.hasItemFleeMult || lhs.itemFleeMult == rhs.itemFleeMult)
  fieldCheck = fieldCheck && (lhs.hasStopMovement == rhs.hasStopMovement) && (!lhs.hasStopMovement || lhs.stopMovement == rhs.stopMovement)
  fieldCheck = fieldCheck && (lhs.hasStopAttack == rhs.hasStopAttack) && (!lhs.hasStopAttack || lhs.stopAttack == rhs.stopAttack)
  fieldCheck = fieldCheck && (lhs.hasTargetMax == rhs.hasTargetMax) && (!lhs.hasTargetMax || lhs.targetMax == rhs.targetMax)
  fieldCheck = fieldCheck && (lhs.hasTargetSlow == rhs.hasTargetSlow) && (!lhs.hasTargetSlow || lhs.targetSlow == rhs.targetSlow)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public extension Pogoprotos.Networking.Responses {
  public struct UseItemCaptureResponseRoot {
    public static var sharedInstance : UseItemCaptureResponseRoot {
     struct Static {
         static let instance : UseItemCaptureResponseRoot = UseItemCaptureResponseRoot()
     }
     return Static.instance
    }
    public var extensionRegistry:ExtensionRegistry

    init() {
      extensionRegistry = ExtensionRegistry()
      registerAllExtensions(extensionRegistry)
    }
    public func registerAllExtensions(registry:ExtensionRegistry) {
    }
  }

  final public class UseItemCaptureResponse : GeneratedMessage, GeneratedMessageProtocol {
    public private(set) var hasSuccess:Bool = false
    public private(set) var success:Bool = false

    public private(set) var hasItemCaptureMult:Bool = false
    public private(set) var itemCaptureMult:Double = Double(0)

    public private(set) var hasItemFleeMult:Bool = false
    public private(set) var itemFleeMult:Double = Double(0)

    public private(set) var hasStopMovement:Bool = false
    public private(set) var stopMovement:Bool = false

    public private(set) var hasStopAttack:Bool = false
    public private(set) var stopAttack:Bool = false

    public private(set) var hasTargetMax:Bool = false
    public private(set) var targetMax:Bool = false

    public private(set) var hasTargetSlow:Bool = false
    public private(set) var targetSlow:Bool = false

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasSuccess {
        try output.writeBool(1, value:success)
      }
      if hasItemCaptureMult {
        try output.writeDouble(2, value:itemCaptureMult)
      }
      if hasItemFleeMult {
        try output.writeDouble(3, value:itemFleeMult)
      }
      if hasStopMovement {
        try output.writeBool(4, value:stopMovement)
      }
      if hasStopAttack {
        try output.writeBool(5, value:stopAttack)
      }
      if hasTargetMax {
        try output.writeBool(6, value:targetMax)
      }
      if hasTargetSlow {
        try output.writeBool(7, value:targetSlow)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasSuccess {
        serialize_size += success.computeBoolSize(1)
      }
      if hasItemCaptureMult {
        serialize_size += itemCaptureMult.computeDoubleSize(2)
      }
      if hasItemFleeMult {
        serialize_size += itemFleeMult.computeDoubleSize(3)
      }
      if hasStopMovement {
        serialize_size += stopMovement.computeBoolSize(4)
      }
      if hasStopAttack {
        serialize_size += stopAttack.computeBoolSize(5)
      }
      if hasTargetMax {
        serialize_size += targetMax.computeBoolSize(6)
      }
      if hasTargetSlow {
        serialize_size += targetSlow.computeBoolSize(7)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Pogoprotos.Networking.Responses.UseItemCaptureResponse> {
      var mergedArray = Array<Pogoprotos.Networking.Responses.UseItemCaptureResponse>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.UseItemCaptureResponse? {
      return try Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Pogoprotos.Networking.Responses.UseItemCaptureResponse {
      return try Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder().mergeFromData(data, extensionRegistry:Pogoprotos.Networking.Responses.UseItemCaptureResponseRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.UseItemCaptureResponse {
      return try Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.UseItemCaptureResponse {
      return try Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.UseItemCaptureResponse {
      return try Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.UseItemCaptureResponse {
      return try Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.UseItemCaptureResponse {
      return try Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder {
      return Pogoprotos.Networking.Responses.UseItemCaptureResponse.classBuilder() as! Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder {
      return try Pogoprotos.Networking.Responses.UseItemCaptureResponse.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.UseItemCaptureResponse) throws -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder {
      return try Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasSuccess {
        jsonMap["success"] = success
      }
      if hasItemCaptureMult {
        jsonMap["itemCaptureMult"] = NSNumber(double:itemCaptureMult)
      }
      if hasItemFleeMult {
        jsonMap["itemFleeMult"] = NSNumber(double:itemFleeMult)
      }
      if hasStopMovement {
        jsonMap["stopMovement"] = stopMovement
      }
      if hasStopAttack {
        jsonMap["stopAttack"] = stopAttack
      }
      if hasTargetMax {
        jsonMap["targetMax"] = targetMax
      }
      if hasTargetSlow {
        jsonMap["targetSlow"] = targetSlow
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.UseItemCaptureResponse {
      return try Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(data:NSData) throws -> Pogoprotos.Networking.Responses.UseItemCaptureResponse {
      return try Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasSuccess {
        output += "\(indent) success: \(success) \n"
      }
      if hasItemCaptureMult {
        output += "\(indent) itemCaptureMult: \(itemCaptureMult) \n"
      }
      if hasItemFleeMult {
        output += "\(indent) itemFleeMult: \(itemFleeMult) \n"
      }
      if hasStopMovement {
        output += "\(indent) stopMovement: \(stopMovement) \n"
      }
      if hasStopAttack {
        output += "\(indent) stopAttack: \(stopAttack) \n"
      }
      if hasTargetMax {
        output += "\(indent) targetMax: \(targetMax) \n"
      }
      if hasTargetSlow {
        output += "\(indent) targetSlow: \(targetSlow) \n"
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasSuccess {
               hashCode = (hashCode &* 31) &+ success.hashValue
            }
            if hasItemCaptureMult {
               hashCode = (hashCode &* 31) &+ itemCaptureMult.hashValue
            }
            if hasItemFleeMult {
               hashCode = (hashCode &* 31) &+ itemFleeMult.hashValue
            }
            if hasStopMovement {
               hashCode = (hashCode &* 31) &+ stopMovement.hashValue
            }
            if hasStopAttack {
               hashCode = (hashCode &* 31) &+ stopAttack.hashValue
            }
            if hasTargetMax {
               hashCode = (hashCode &* 31) &+ targetMax.hashValue
            }
            if hasTargetSlow {
               hashCode = (hashCode &* 31) &+ targetSlow.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.UseItemCaptureResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.UseItemCaptureResponse"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Pogoprotos.Networking.Responses.UseItemCaptureResponse.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Pogoprotos.Networking.Responses.UseItemCaptureResponse = Pogoprotos.Networking.Responses.UseItemCaptureResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.UseItemCaptureResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasSuccess:Bool {
           get {
                return builderResult.hasSuccess
           }
      }
      public var success:Bool {
           get {
                return builderResult.success
           }
           set (value) {
               builderResult.hasSuccess = true
               builderResult.success = value
           }
      }
      public func setSuccess(value:Bool) -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder {
        self.success = value
        return self
      }
      public func clearSuccess() -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder{
           builderResult.hasSuccess = false
           builderResult.success = false
           return self
      }
      public var hasItemCaptureMult:Bool {
           get {
                return builderResult.hasItemCaptureMult
           }
      }
      public var itemCaptureMult:Double {
           get {
                return builderResult.itemCaptureMult
           }
           set (value) {
               builderResult.hasItemCaptureMult = true
               builderResult.itemCaptureMult = value
           }
      }
      public func setItemCaptureMult(value:Double) -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder {
        self.itemCaptureMult = value
        return self
      }
      public func clearItemCaptureMult() -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder{
           builderResult.hasItemCaptureMult = false
           builderResult.itemCaptureMult = Double(0)
           return self
      }
      public var hasItemFleeMult:Bool {
           get {
                return builderResult.hasItemFleeMult
           }
      }
      public var itemFleeMult:Double {
           get {
                return builderResult.itemFleeMult
           }
           set (value) {
               builderResult.hasItemFleeMult = true
               builderResult.itemFleeMult = value
           }
      }
      public func setItemFleeMult(value:Double) -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder {
        self.itemFleeMult = value
        return self
      }
      public func clearItemFleeMult() -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder{
           builderResult.hasItemFleeMult = false
           builderResult.itemFleeMult = Double(0)
           return self
      }
      public var hasStopMovement:Bool {
           get {
                return builderResult.hasStopMovement
           }
      }
      public var stopMovement:Bool {
           get {
                return builderResult.stopMovement
           }
           set (value) {
               builderResult.hasStopMovement = true
               builderResult.stopMovement = value
           }
      }
      public func setStopMovement(value:Bool) -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder {
        self.stopMovement = value
        return self
      }
      public func clearStopMovement() -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder{
           builderResult.hasStopMovement = false
           builderResult.stopMovement = false
           return self
      }
      public var hasStopAttack:Bool {
           get {
                return builderResult.hasStopAttack
           }
      }
      public var stopAttack:Bool {
           get {
                return builderResult.stopAttack
           }
           set (value) {
               builderResult.hasStopAttack = true
               builderResult.stopAttack = value
           }
      }
      public func setStopAttack(value:Bool) -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder {
        self.stopAttack = value
        return self
      }
      public func clearStopAttack() -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder{
           builderResult.hasStopAttack = false
           builderResult.stopAttack = false
           return self
      }
      public var hasTargetMax:Bool {
           get {
                return builderResult.hasTargetMax
           }
      }
      public var targetMax:Bool {
           get {
                return builderResult.targetMax
           }
           set (value) {
               builderResult.hasTargetMax = true
               builderResult.targetMax = value
           }
      }
      public func setTargetMax(value:Bool) -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder {
        self.targetMax = value
        return self
      }
      public func clearTargetMax() -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder{
           builderResult.hasTargetMax = false
           builderResult.targetMax = false
           return self
      }
      public var hasTargetSlow:Bool {
           get {
                return builderResult.hasTargetSlow
           }
      }
      public var targetSlow:Bool {
           get {
                return builderResult.targetSlow
           }
           set (value) {
               builderResult.hasTargetSlow = true
               builderResult.targetSlow = value
           }
      }
      public func setTargetSlow(value:Bool) -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder {
        self.targetSlow = value
        return self
      }
      public func clearTargetSlow() -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder{
           builderResult.hasTargetSlow = false
           builderResult.targetSlow = false
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.UseItemCaptureResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder {
        return try Pogoprotos.Networking.Responses.UseItemCaptureResponse.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.UseItemCaptureResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.UseItemCaptureResponse {
        let returnMe:Pogoprotos.Networking.Responses.UseItemCaptureResponse = builderResult
        return returnMe
      }
      public func mergeFrom(other:Pogoprotos.Networking.Responses.UseItemCaptureResponse) throws -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder {
        if other == Pogoprotos.Networking.Responses.UseItemCaptureResponse() {
         return self
        }
        if other.hasSuccess {
             success = other.success
        }
        if other.hasItemCaptureMult {
             itemCaptureMult = other.itemCaptureMult
        }
        if other.hasItemFleeMult {
             itemFleeMult = other.itemFleeMult
        }
        if other.hasStopMovement {
             stopMovement = other.stopMovement
        }
        if other.hasStopAttack {
             stopAttack = other.stopAttack
        }
        if other.hasTargetMax {
             targetMax = other.targetMax
        }
        if other.hasTargetSlow {
             targetSlow = other.targetSlow
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            success = try input.readBool()

          case 17:
            itemCaptureMult = try input.readDouble()

          case 25:
            itemFleeMult = try input.readDouble()

          case 32:
            stopMovement = try input.readBool()

          case 40:
            stopAttack = try input.readBool()

          case 48:
            targetMax = try input.readBool()

          case 56:
            targetSlow = try input.readBool()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder()
        if let jsonValueSuccess = jsonMap["success"] as? Bool {
          resultDecodedBuilder.success = jsonValueSuccess
        }
        if let jsonValueItemCaptureMult = jsonMap["itemCaptureMult"] as? NSNumber {
          resultDecodedBuilder.itemCaptureMult = jsonValueItemCaptureMult.doubleValue
        }
        if let jsonValueItemFleeMult = jsonMap["itemFleeMult"] as? NSNumber {
          resultDecodedBuilder.itemFleeMult = jsonValueItemFleeMult.doubleValue
        }
        if let jsonValueStopMovement = jsonMap["stopMovement"] as? Bool {
          resultDecodedBuilder.stopMovement = jsonValueStopMovement
        }
        if let jsonValueStopAttack = jsonMap["stopAttack"] as? Bool {
          resultDecodedBuilder.stopAttack = jsonValueStopAttack
        }
        if let jsonValueTargetMax = jsonMap["targetMax"] as? Bool {
          resultDecodedBuilder.targetMax = jsonValueTargetMax
        }
        if let jsonValueTargetSlow = jsonMap["targetSlow"] as? Bool {
          resultDecodedBuilder.targetSlow = jsonValueTargetSlow
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:NSData) throws -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder {
        let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

}

// @@protoc_insertion_point(global_scope)
